{
	"schemaVersion": "2.0.0",
	"contractName": "ITokenBridge",
	"compilerOutput": {
		"abi": [
			{
				"constant": false,
				"inputs": [
					{
						"name": "_targetBridge",
						"type": "bytes32"
					},
					{
						"name": "_token",
						"type": "address"
					},
					{
						"name": "_receiver",
						"type": "address"
					},
					{
						"name": "_amount",
						"type": "uint256"
					},
					{
						"name": "_chainId",
						"type": "uint256"
					},
					{
						"name": "_salt",
						"type": "uint256"
					}
				],
				"name": "_createBridgeTokenEvent",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "tokenBridgeId",
				"outputs": [
					{
						"name": "",
						"type": "bytes32"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [
					{
						"name": "",
						"type": "bytes32"
					}
				],
				"name": "processedEvents",
				"outputs": [
					{
						"name": "",
						"type": "bool"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "eventEmitter",
				"outputs": [
					{
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "eventListener",
				"outputs": [
					{
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "targetBridge",
						"type": "bytes32"
					},
					{
						"name": "_token",
						"type": "address"
					},
					{
						"name": "_receiver",
						"type": "address"
					},
					{
						"name": "_amount",
						"type": "uint256"
					},
					{
						"name": "_chainId",
						"type": "uint256"
					},
					{
						"name": "_salt",
						"type": "uint256"
					}
				],
				"name": "_getTokensBridgedEventHash",
				"outputs": [
					{
						"name": "",
						"type": "bytes32"
					}
				],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"name": "_token",
						"type": "address"
					},
					{
						"name": "_receiver",
						"type": "address"
					},
					{
						"name": "_amount",
						"type": "uint256"
					},
					{
						"name": "_chainId",
						"type": "uint256"
					},
					{
						"name": "_salt",
						"type": "uint256"
					},
					{
						"name": "_proof",
						"type": "bytes32[]"
					},
					{
						"name": "_proofPaths",
						"type": "bool[]"
					},
					{
						"name": "_interchainStateRoot",
						"type": "bytes32"
					},
					{
						"name": "_eventsProof",
						"type": "bytes32[]"
					},
					{
						"name": "_eventsPaths",
						"type": "bool[]"
					},
					{
						"name": "_eventsRoot",
						"type": "bytes32"
					}
				],
				"name": "claim",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "constructor"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": false,
						"name": "eventHash",
						"type": "bytes32"
					},
					{
						"indexed": false,
						"name": "targetBridge",
						"type": "bytes32"
					},
					{
						"indexed": true,
						"name": "chainId",
						"type": "uint256"
					},
					{
						"indexed": true,
						"name": "receiver",
						"type": "address"
					},
					{
						"indexed": true,
						"name": "token",
						"type": "address"
					},
					{
						"indexed": false,
						"name": "amount",
						"type": "uint256"
					},
					{
						"indexed": false,
						"name": "_salt",
						"type": "uint256"
					}
				],
				"name": "TokensBridged",
				"type": "event"
			}
		],
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x",
				"opcodes": "",
				"sourceMap": ""
			},
			"deployedBytecode": {
				"linkReferences": {},
				"object": "0x",
				"opcodes": "",
				"sourceMap": ""
			}
		}
	},
	"sources": {
		"bridge/ITokenBridge.sol": {
			"id": 4
		},
		"events/EventEmitter.sol": {
			"id": 5
		},
		"MerkleTreeVerifier.sol": {
			"id": 1
		},
		"events/EventListener.sol": {
			"id": 6
		}
	},
	"sourceCodes": {
		"bridge/ITokenBridge.sol": "pragma solidity ^0.5.0;\n\nimport \"../events/EventEmitter.sol\";\nimport \"../events/EventListener.sol\";\n\ncontract ITokenBridge {\n    uint256 chainId;\n    bytes32 public tokenBridgeId;\n    EventListener public eventListener;\n    EventEmitter public eventEmitter;\n\n    mapping(bytes32 => bool) public processedEvents;\n\n    event TokensBridged(\n        bytes32 eventHash, \n        bytes32 targetBridge, \n        uint256 indexed chainId, address indexed receiver, address indexed token, uint256 amount, uint256 _salt\n    );\n\n    constructor() public {\n        tokenBridgeId = keccak256(abi.encodePacked(this, blockhash(1)));\n    }\n    \n    function _createBridgeTokenEvent(\n        bytes32 _targetBridge, \n        address _token, address _receiver, uint256 _amount, uint256 _chainId, uint256 _salt\n    ) public {\n        bytes32 eventHash = _getTokensBridgedEventHash(\n            _targetBridge, _token, _receiver, _amount, _chainId, _salt\n        );\n        emit TokensBridged(eventHash, _targetBridge, _chainId, _receiver, _token, _amount, _salt);\n        eventEmitter.emitEvent(eventHash);\n    }\n\n    function _getTokensBridgedEventHash(\n        bytes32 targetBridge,\n        address _token, address _receiver, uint256 _amount, uint256 _chainId, uint256 _salt\n    ) public returns (bytes32) {\n        return keccak256(abi.encodePacked(\n            targetBridge, _receiver, _token, _amount, _chainId, _salt\n        ));\n    }\n\n    function claim(\n        address _token,\n        address _receiver,\n        uint256 _amount,\n        uint256 _chainId,\n        uint256 _salt,\n        bytes32[] memory _proof,\n        bool[] memory _proofPaths,\n        bytes32 _interchainStateRoot,\n        bytes32[] memory _eventsProof,\n        bool[] memory _eventsPaths,\n        bytes32 _eventsRoot\n    ) public;\n\n    function _checkEventProcessed(bytes32 eventHash) internal {\n        require(!processedEvents[eventHash], \"EVENT_ALREADY_PROCESSED\");\n        processedEvents[eventHash] = true;\n    }\n}",
		"events/EventEmitter.sol": "pragma solidity ^0.5.0;\n\nimport \"../MerkleTreeVerifier.sol\";\n\ncontract EventEmitter is MerkleTreeVerifier {\n    // Events pending acknowledgement on other chains.\n    bytes32[] public events;\n\n    event EventEmitted(bytes32 eventHash); \n\n    constructor() public {\n    }\n\n    function emitEvent(bytes32 _eventHash) public returns(bool) {\n        require(_eventHash != 0x0, \"INVALID_EVENT\");\n        events.push(_eventHash);\n        emit EventEmitted(_eventHash);\n        // keccak256(abi.encodePacked(msg.sender, _eventHash)) is whats added to the merkle tree of that chain\n        // TODO: Implement fee system\n        return true;\n    }\n\n    function acknowledgeEvents() public {\n        // delete pendingEvents;\n    }\n\n    function getEventsCount() public view returns (uint) {\n        return events.length;\n    }\n\n    function getEventsRoot() public view returns(bytes32) {\n        if(events.length == 0) return 0x0000000000000000000000000000000000000000000000000000000000000000;\n        return _computeMerkleRoot(events);\n    }\n\n}",
		"MerkleTreeVerifier.sol": "pragma solidity ^0.5.0;\n\ncontract MerkleTreeVerifier {\n    function math_log2(uint x) public pure returns (uint y){\n        assembly {\n            let arg := x\n            x := sub(x,1)\n            x := or(x, div(x, 0x02))\n            x := or(x, div(x, 0x04))\n            x := or(x, div(x, 0x10))\n            x := or(x, div(x, 0x100))\n            x := or(x, div(x, 0x10000))\n            x := or(x, div(x, 0x100000000))\n            x := or(x, div(x, 0x10000000000000000))\n            x := or(x, div(x, 0x100000000000000000000000000000000))\n            x := add(x, 1)\n            let m := mload(0x40)\n            mstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\n            mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\n            mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\n            mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\n            mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\n            mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\n            mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\n            mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\n            mstore(0x40, add(m, 0x100))\n            let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\n            let shift := 0x100000000000000000000000000000000000000000000000000000000000000\n            let a := div(mul(x, magic), shift)\n            y := div(mload(add(m,sub(255,a))), shift)\n            y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\n        }  \n    }\n\n    function _computeMerkleRoot(bytes32[] memory items) public pure returns (bytes32) {\n        for(uint i = 0; i < items.length; i++) {\n            items[i] = _hashLeaf(items[i]);\n        }\n\n        // extend layer to be a power of 2\n        // this simplifies logic later\n        bytes32[] memory layer = _getBalancedLayer(items);\n\n        while(layer.length > 1) {\n            layer = _computeLayer(layer);\n        }\n\n        return layer[0];\n    }\n\n    function _getBalancedLayer(bytes32[] memory items) public pure returns (bytes32[] memory) {\n        uint powerOf2Size = 2 ** math_log2(items.length);\n        if(items.length == 1) {\n            powerOf2Size = 2; \n        }\n        bytes32[] memory layer = new bytes32[](powerOf2Size);\n        for(uint i = 0; i < layer.length; i++) {\n            if(i < items.length) {\n                layer[i] = items[i];\n            } else {\n                // duplicate last leaf\n                layer[i] = items[items.length - 1];\n            }\n        }\n        return layer;\n    }\n\n    function _computeLayer(bytes32[] memory layer) public pure returns (bytes32[] memory) {\n        // uint nLayers = log2(layer.length);\n        // bytes32[] memory nextLayer = new bytes32[](2**(nLayers-1));\n        require(layer.length == 2 ** math_log2(layer.length), \"NOT_PERFECT_POWEROF2\");\n        \n        bytes32[] memory nextLayer = new bytes32[](layer.length / 2);\n        \n        for(uint i = 0; i < nextLayer.length; i++) {\n            uint left = i * 2;\n            uint right = left + 1;\n\n            // if(layer.length % 2 == 1) {\n            //     if(right == layer.length) {\n            //         right = left;\n            //     }\n            // }\n\n            nextLayer[i] = _hashBranch(layer[left], layer[right]);\n        }\n\n        return nextLayer;\n    }\n\n\n    /**\n     * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\n     * and each pair of pre-images are sorted.\n     * @param proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\n     * @param root Merkle root\n     * @param leaf Leaf of Merkle tree\n     */\n    function _verify(bytes32[] memory proof, bool[] memory paths, bytes32 root, bytes32 leaf) public pure returns (bool) {\n        // Check if the computed hash (root) is equal to the provided root\n        return _computeRoot(proof, paths, leaf) == root;\n    }\n\n    function _computeRoot(bytes32[] memory proof, bool[] memory paths, bytes32 leaf) public pure returns (bytes32) {        \n        bytes32 node = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 pairNode = proof[i];\n\n            if (paths[i]) {\n                // Hash(current element of the proof + current computed hash)\n                node = _hashBranch(pairNode, node);\n            } else {\n                // Hash(current computed hash + current element of the proof)\n                node = _hashBranch(node, pairNode);\n            }\n        }\n\n        return node;\n    }\n    \n    function _hashLeaf(bytes32 leaf) public pure returns (bytes32) {\n        bytes1 LEAF_PREFIX = 0x00;\n        return keccak256(abi.encodePacked(LEAF_PREFIX, leaf));\n    }\n\n    function _hashBranch(bytes32 left, bytes32 right) public pure returns (bytes32) {\n        bytes1 BRANCH_PREFIX = 0x01;\n        return keccak256(abi.encodePacked(BRANCH_PREFIX, left, right));\n    }\n}",
		"events/EventListener.sol": "pragma solidity ^0.5.0;\n\nimport \"./EventEmitter.sol\";\nimport \"../MerkleTreeVerifier.sol\";\n\ncontract EventListener is MerkleTreeVerifier {\n    // The interchain state root.\n    bytes32 public interchainStateRoot;\n    // bytes32 public acknowledgedEventsRoot;\n    \n    // The last recorded root of this chain on other chains.\n    bytes32 public lastAttestedStateRoot;\n\n    // bytes32 public bridgeId;\n\n    EventEmitter emitter;\n\n    // bytes32 public stateRoot;\n    uint public _stateRootUpdated;\n\n    mapping(bytes32 => uint) stateRootToChainRoot;\n\n    mapping(uint256 => bytes32[]) chainIdToProofs; \n\n    event StateRootUpdated(bytes32 indexed root);\n    event ProofSubmitted(uint256 indexed chainId, bytes32 indexed proof);\n\n    constructor(EventEmitter _emitter) public {\n        bytes32 nonce = keccak256(abi.encodePacked(this, blockhash(1)));\n        _updateStateRoot(nonce);\n        emitter = _emitter;\n    }\n\n    function _updateStateRoot(bytes32 root) internal {\n        // stateRootToChainRoot[root] = block.timestamp;\n        // stateRoots.push(root);\n        // stateRoot = root;\n        // stateRootUpdated = block.timestamp;\n        interchainStateRoot = root;\n        emit StateRootUpdated(root);\n        // _ackPendingEvents();\n    }\n\n    function checkEvent(\n        bytes32[] memory proof, \n        bool[] memory paths, \n        bytes32 _interchainStateRoot, \n        \n        bytes32[] memory _eventsProof,\n        bool[] memory _eventsPaths,\n        bytes32 _eventsRoot,\n        bytes32 _eventHash\n    ) public returns (bool) {\n        // Verify the events root for that chain's bridge.\n        bytes32 bridgeLeaf = _hashLeaf2(_interchainStateRoot, _eventsRoot);\n        require(_verify(proof, paths, _interchainStateRoot, bridgeLeaf), \"STATEROOT_PROOF_INVALID\");\n\n        // Verify the event hash\n        require(_verify(_eventsProof, _eventsPaths, bridgeLeaf, _eventHash), \"EVENT_PROOF_INVALID\");\n\n        return true;\n    }\n    \n    // function checkEvent(uint256 _chainId, uint256 _period, bytes32[] memory _proof, bool[] memory paths, bytes32 _leaf) public returns(bool) {\n    //     return _verify(_proof, paths, chainIdToProofs[_chainId][_period], _leaf);\n    // }\n\n    // function getProof(uint256 _chainId, uint256 _index) public view returns(bytes32) {\n    //     return chainIdToProofs[_chainId][_index]; \n    // }\n\n    // function getLatestProof(uint256 _chainId) public view returns(bytes32) {\n    //     return getProof(_chainId, chainIdToProofs[_chainId].length - 1);\n    // }\n\n    // function updateProof(uint256 _chainId, bytes32 _proof) public {\n    //     chainIdToProofs[_chainId].push(_proof);\n    //     emit ProofSubmitted(_chainId, _proof);\n    // }\n\n    // TODO only the relayer(s) should be able to update the proof\n    function updateStateRoot(\n        bytes32[] memory _proof, \n        bool[] memory _proofPaths,\n        bytes32 _newInterchainStateRoot, \n        bytes32 _interchainStateRoot, \n        bytes32 _eventsRoot\n    ) public {\n        // todo\n        // ACL for only validators\n        // and groupsig\n\n        // if the validators attempt to exploit arbitrage of time between chains\n        // this proof can be used on all other bridges to shut them down (slashing)\n\n\n        // require(block.timestamp > stateRootUpdated, \"BACK_IN_TIME_ERR\");\n\n        // It must reference the previous interchain state root and prove we build upon it.\n        require(_interchainStateRoot == interchainStateRoot, \"INVALID_STATE_CHRONOLOGY\");\n        require(_newInterchainStateRoot != interchainStateRoot, \"HUH\");\n\n        // TODO - Verify this chain's events are acknowledged        \n        // bytes32 eventsRoot = MerkleProof.computeRoot(EventEmitter.getPendingEvents());\n        require(emitter.getEventsRoot() == _eventsRoot, \"EVENTS_NOT_ACKNOWLEDGED\");\n\n        bytes32 chainLeaf = _hashLeaf2(_interchainStateRoot, _eventsRoot);\n        require(_verify(_proof, _proofPaths, _newInterchainStateRoot, chainLeaf) == true, \"INTERCHAIN_STATE_ROOT_PROOF_INCORRECT\");\n        \n        _updateStateRoot(_newInterchainStateRoot);\n        \n        emitter.acknowledgeEvents();\n    }\n\n    function _hashLeaf2(bytes32 b, bytes32 c) public pure returns (bytes32) {\n        bytes1 LEAF_PREFIX = 0x00;\n        return keccak256(abi.encodePacked(LEAF_PREFIX, b, c));\n    }\n}"
	},
	"sourceTreeHashHex": "0x7f1e0b17cb11e87a792b18e455669a12bc2585bff8a8c14501b847c7d4cf66b7",
	"compiler": {
		"name": "solc",
		"version": "soljson-v0.5.4+commit.9549d8ff.js",
		"settings": {
			"optimizer": {
				"enabled": true
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"evm.bytecode.object",
						"evm.bytecode.sourceMap",
						"evm.deployedBytecode.object",
						"evm.deployedBytecode.sourceMap"
					]
				}
			},
			"remappings": [
				"openzeppelin-solidity=/Users/liamz/Documents/open-source/0dex/contracts/node_modules/openzeppelin-solidity"
			]
		}
	},
	"networks": {}
}